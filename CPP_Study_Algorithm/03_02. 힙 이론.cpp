#include <iostream>
#include <vector>
#include <list>
#include <stack>
#include <queue>
using namespace std;

// 힙 이론
// 시간 복잡도는 log n

// 이진 트리
// : 각 노드가 '최대 두개'의 자식 노드를 가지는 트리
// : 자식 노드가 0, 1, 2개 일 수도 있다.

// 이진 검색 트리 특징(조건)
// 왼쪽을 타고 가면 현재 값보다 작다.
// 오른쪽을 타고 가면 현재 값보다 크다.
// [!] 무식하게 추가하면, 데이터가 한쪽으로 기울어져서 균형이 깨진다.
// [!] 트리 재배치를 통해 균형을 유지하는 것이 과제다. (AVL, Red-Black)

// 힙 트리
// 힙 트리도 이진 트리의 한 종류다.
// 힙 트리 1법칙 : 부모 노드가 가진 값은 '항상' 자식 노드가 가진 값보다 크다.
// 힙 트리 2법칙 : 노드 개수를 알면, 트리 구조는 무조건 확정할 수 있다.
// - 마지막 레벨을 제외한 모든 레벨에 노드가 꽉 차 있어야 한다. - 완전 이진 트리
// - 마지막 레벨에 노드가 있을 때는, 항상 왼쪽부터 순서대로 채워야 한다.

// 힙 트리 구조의 특징
// 1) i 번 노드의 왼쪽 자식은        [ (2 * i) + 1 ] 번
// 2) i 번 노드의 오른쪽 자식은      [ (2 * i) + 2 ] 번
// 3) i 번 노드의 부모는             [ (i - 1) / 2 ] 번
// - 힙 트리는 하나의 배열로 만들어서 관리할 수 있다.
// - 데이터 개수가 정해지면, 트리의 구조가 정해지기 때문이다.

// 힙 트리에 새로운 값 추가
// 2법칙 - 1) 우선 트리 구조부터 맞춰준다. 
// 1법칙 - 2) 새로 추가된 값과 기존 값을 계속 비교하여 힙 트리의 조건을 맞춰준다. - 도장깨기

// 힙 트리 최대값 꺼내기
// 힙 트리는 모든 데이터를 관리하여 추가 및 삭제를 하는 용도가 아니라, 제일 큰 값, 제일 작은 값을 꺼내기 위함
// [!] 최대값 / 최소값을 찾는데 유용함!
// 힙 트리 특성상 최대값은 무조건 루트 노드에 있는 값이다.
// 최대값을 꺼내서 사용했으면 다시 힙 트리의 구조를 맞춰줘야 한다.
// 1) 최대값을 먼저 제거한다.
// 2) 제일 마지막에 위치한 데이터를 루트로 옮긴다.
// 3) 역으로 도장깨기를 시작한다.

int main()
{
    
}